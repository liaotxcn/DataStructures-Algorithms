# DataStructures-Algorithms 数构与算法 📊  

<div align="center">  

![Python](https://img.shields.io/badge/Python-3776AB?style=for-the-badge&logo=python&logoColor=white)
![Go](https://img.shields.io/badge/Go-00ADD8?style=for-the-badge&logo=go&logoColor=white)  

</div>  

---

## 📂 项目结构  

### **Python 版本** 🐍  
- **`First.py`**  
  - 基础数据结构实现  
  - 常用算法模板和实例  
- **`Second.py`**  
  - 高级数据结构  
  - 进阶算法实现、应用案例

### **Golang 版本** 🦫  
- **`First.go`**  
  - 基础数据结构(链表、队列、双端队列、栈、集合、图等)
  - 常用算法(排序、搜索、动态规划等)
  - 工具实例(字符串处理、切片操作等)
- **`Second.go`**  
  - 并发安全数据结构(Map、Slice、Queue等)
  - Goroutine管理(工作池、优雅退出等模式)
  - Channel高级模式(Fan-in、Fan-out、超时控制等)
  - 原子操作与并发原语(计数器、Once等)
  - 经典并发模式(生产者消费者等)
- **`Third.go`**  
  - 高级Goroutine模式、Channel、并发实用
  - 分片并发安全Map实现(Set、Get、getShard)
  - 并发安全环形缓冲区(Put、Get)
  - 动态Worker Pool实现
  - 高级并发模式(Context、Channel多路复用、限速器、ErrorGroup增强版)
  - 工具函数实例(FNV32哈希算法实现、并发原语等)
- **`Cache elimination 缓存淘汰`**
  - FIFO   按照数据最早进入顺序淘汰数据
  - LRU    根据数据最近使用情况淘汰数据
  - LFU    根据数据访问频率来淘汰数据
  - ARC    LRU + LFU
- **`Snowflake 高可用雪花`**
  - Snowflake 雪花算法
- **`RateLimiting 高效限流`**
  - RateLimiting 限流算法

---

## 缓存淘汰(FIFO、LRU、LFU、ARC)
### FIFO(先进先出)
- **原理**：优先淘汰最早进入缓存的数据
- **实现方式**：使用队列记录数据进入顺序
- **特点**：
  - ✅ 实现简单，内存开销低  
  - ❌ 可能误删高频访问的早期数据
- **示例**（容量=3）：  
  访问序列：A → B → C → A → D  
  淘汰顺序：B（最早进入且未重复访问）
![image](https://github.com/user-attachments/assets/fe7b6a29-a622-4471-8267-7d2afb419c8f)

### LRU(最近最少使用)
- **原理**：淘汰最久未被访问的数据
- **实现方式**：哈希表+双向链表（O(1)复杂度）
- **特点**：
  - ✅ 符合时间局部性原理  
  - ❌ 突发流量可能挤出热点数据
- **示例**（容量=3）：  
  访问序列：A → B → C → A → D → B → E  
  淘汰顺序：C（最久未访问）→ A → D
![image](https://github.com/user-attachments/assets/6a1fc97e-e35e-4b10-bad7-646642013ca9)

### LFU(最不经常使用)
- **原理**：淘汰访问频率最低的数据（频率相同则按LRU）
- **实现方式**：最小堆/多层链表+频率哈希表
- **特点**：
  - ✅ 适合长期热点场景  
  - ❌ 容易积累"缓存污染"数据
- **示例**（容量=2）：  
  访问序列：A → A → B → A → C → B → C  
  淘汰顺序：B（频率1）→ A（频率3保留）
![image](https://github.com/user-attachments/assets/fa84f11a-35bb-4379-ada2-f6c06922946b)

### ARC(自适应替换缓存)
- **原理**：动态平衡LRU和LFU策略
- **实现方式**：维护4个队列（T1/T2/B1/B2）
- **特点**：
  - ✅ 自适应各种访问模式  
  - ❌ 实现复杂，内存占用高
- **工作模式**：根据命中率自动调整LRU/LFU权重
![image](https://github.com/user-attachments/assets/ebe32488-0c6b-4886-8770-fa54ea3ac42e)

### 对比
| 算法     | 时间复杂度 | 空间复杂度 | 最佳适用场景         |
|----------|------------|------------|----------------------|
| FIFO     | O(1)       | O(n)       | 顺序访问场景         |
| LRU      | O(1)       | O(n)       | 短期热点数据         |
| LFU      | O(log n)   | O(n)       | 长期稳定热点         |
| ARC      | O(1)       | O(n)       | 复杂多变访问模式     |

### 选型
- **低成本实现**：FIFO
- **通用场景**：LRU（Redis默认策略(改进LRU)）
- **稳定热点**：LFU
- **高性能系统**：ARC（数据库缓存常用）
## Redis改进版LRU、LFU
### LRU
- 传统LRU算法基于链表实现，链表中元素按照顺序从前到后排列，最新操作的键会被移动到表头，进行内存淘汰时，则删除链表尾部元素(即最久未被使用的元素)
- 传统LRU弊端1：需要用链表管理所有缓存数据，带来额外空间开销
- 传统LRU弊端2：当有数据被访问时，需在链表上将该数据移动到表头位置，若有大量数据被访问，就会带来大量的链表移动操作，时间耗费长，进而降低Redis缓存性能
- Redis改进LRU算法：在Redis对象结构体中添加一个额外的字段，用于记录此数据最后一次访问时间，进行内存淘汰时，采用随机采样（默认取5个键）而非全局排序，从中淘汰最久未使用的键，以减少性能开销
- 配置参数：maxmemory-policy allkeys-lru（所有键参与淘汰）
           maxmemory-policy volatile-lru（仅带过期时间的键参与淘汰）
- 优点：不用为所有数据维护一个大表链，节省空间占用；不用在每次数据访问时都移动链表项，提升缓存性能，适合大多数访问模式(如热点数据场景)
- 存在无法解决缓存污染的问题(一次读取大量数据，且只会被读取一次，大量数据长时间留存Redis)
### LFU
- 频率统计：基于计数器（Morris 计数器）近似统计访问频率，节省内存
- 衰减机制：计数器随时间衰减（通过 lfu-decay-time 配置），避免旧数据长期占据内存
- 配置参数：maxmemory-policy allkeys-lfu 或 volatile-lfu
           lfu-log-factor 调整计数器增长速率（值越大，区分低频访问越精细）
- 优点：更适合长尾访问分布（如某些数据偶尔访问但不应保留）
- 对突发访问敏感，新数据可能因初始频率低被误删
### 场景选择
- LRU：适合有明显热点数据的场景（如用户近期访问记录）
- LFU：适合访问模式均匀或需要长期频率统计的场景（如缓存广告数据）
- 其他策略：若无需精确淘汰，可结合 TTL（如 volatile-ttl）或随机淘汰（allkeys-random）
```bash
# 使用 LFU 淘汰所有键
maxmemory-policy allkeys-lfu
lfu-log-factor 10
lfu-decay-time 1

# 使用 LRU 淘汰仅带过期时间的键
maxmemory-policy volatile-lru
```
- 采样数量：通过 maxmemory-samples 调整 LRU/LFU 的采样精度（增加样本数提高准确性，但消耗更多CPU）
- 混合策划：Redis 6.2+ 支持 volatile-lfu 和 volatile-lru 对带过期时间的键灵活控制

---

## 雪花算法
雪花算法(Snowflake)是一种分布式ID生成算法，用于在分布式系统中生成全局唯一且有序的ID
### 特点
- 唯一性：在分布式环境下生成的ID不会重复
- 有序性：生成的ID随时间递增
- 高性能：本地生成，不依赖数据库等外部系统
### 生成ID结构
典型的雪花算法生成的64位ID由以下几部分组成
```bash
0 - 0000000000 0000000000 0000000000 0000000000 0 - 00000 - 00000 - 000000000000
```
- 1位符号位：始终为0，表示正数
- 41位时间戳：记录当前时间与自定义起始时间的差值（毫秒级）
- 10位工作机器ID：5位数据中心ID + 5位机器ID
- 12位序列号：同一毫秒内的序列号
### 业务应用
- 分布式系统主键生成：数据库主键、消息ID等
- 订单号生成：电商、支付等业务
- 日志追踪ID：分布式系统调用链追踪
- 社交网络中的帖子/评论ID：如微博、Twitter等
### 注意事项
- 时钟回拨问题：如果系统时间被回调，可能导致ID重复
- workerID分配：需要确保不同机器的workerID不重复
- 起始时间选择：epoch的选择影响ID的有效期（41位时间戳大约可用69年）

---

## 限流算法
限流算法（Rate Limiting Algorithms）用于控制系统的请求处理速率，防止过载，保障服务的稳定性和公平性
### 固定窗口计数器(Fixed window counter)
- 原理：将时间划分为固定窗口（如1分钟），统计每个窗口内的请求数，超过阈值则拒绝请求
- 优点：实现简单，内存占用少
- 缺点：窗口边界可能突发流量（如窗口切换时瞬间涌入大量请求）
  ![image](https://github.com/user-attachments/assets/9148ddae-c352-403e-a9cb-d925cc773b04)

### 滑动窗口计数器(Sliding window counter)
- 原理：记录请求的时间戳，统计当前时间向前滑动窗口（如1分钟）内的请求数
- 精确版：保存所有请求时间戳（精确但耗内存）
- 近似版：使用小窗口分段统计（如将1分钟分为6个10秒窗口，牺牲精度换性能）
- 优点：平滑限流，避免固定窗口的边界问题
- 缺点：实现较复杂，内存或计算成本较高
![image](https://github.com/user-attachments/assets/e4bcb554-1ac6-40d7-bacd-013c155bab3b)

### 漏桶算法(Leaky bucket)
- 原理：请求以任意速率进入桶，以恒定速率流出（如每秒10次）。桶满则拒绝请求
- 优点：平滑输出流量，避免突发压力
- 缺点：无法应对短时突发流量（即使系统有空闲资源也会限流）
- 场景：适合需要严格控制处理速率的场景（如消息队列）
### 令牌桶算法(Token bucket)
- 原理：桶以固定速率生成令牌（如每秒5个）、请求需获取令牌，无令牌则被限流、桶有最大容量，允许短时突发（如桶容量10，瞬间消耗10令牌）
- 优点：兼顾平滑限流和突发流量处理
- 缺点：需维护令牌生成和桶状态
- 场景：API限流（如AWS、Google Cloud的限流服务）
![image](https://github.com/user-attachments/assets/fbbfafdd-99f8-4cdc-8eb9-6de276faa16c)

### 自适应限流
- 原理：动态调整阈值，基于系统指标（如CPU、延迟、错误率）实时反馈
- 实例：TCP拥塞控制（类似慢启动、拥塞避免机制）、梯度下降（根据错误率调整限流阈值）
- 优点：灵活应对流量波动，最大化资源利用率
- 缺点：实现复杂，需监控系统状态
### 分布式限流
- 实例：集群中全局共享限流状态（如N个节点共享每秒1000次请求）
- Redis + Lua 集中存储计数，原子操作（如INCR+EXPIRE）
- 分片：每个节点负责部分限流，汇总结果
- 一致性哈希：减少节点变化的影响
### 对比
| 算法                | 原理                                                                 | 优点                          | 缺点                                  | 适用场景                     |
|---------------------|----------------------------------------------------------------------|-------------------------------|---------------------------------------|------------------------------|
| **固定窗口计数器**  | 按固定时间窗口（如1分钟）计数，超限则拒绝请求。                      | 实现简单，内存占用低。        | 窗口边界可能突发流量（如请求翻倍）。  | 简单限流，允许一定误差。      |
| **滑动窗口计数器**  | 统计滑动时间窗口（如最近1分钟）内的请求数，超限则拒绝。               | 比固定窗口更平滑，限流更精确。| 实现复杂，内存或计算成本较高。        | 高精度限流（如API网关）。     |
| **漏桶算法**        | 请求以任意速率进入桶，以恒定速率流出（如每秒10次），桶满则拒绝。      | 输出流量绝对平滑。            | 无法处理突发流量，即使系统有空闲资源。| 消息队列、流量整形。          |
| **令牌桶算法**      | 桶以固定速率生成令牌，请求需消耗令牌，无令牌则限流，允许短时突发。    | 兼顾平滑限流和突发流量处理。  | 需维护令牌生成逻辑。                  | 云API限流（如AWS、Google）。  |
| **自适应限流**      | 动态调整限流阈值，基于系统指标（CPU、延迟等）实时反馈。               | 灵活，最大化资源利用率。      | 实现复杂，需监控系统状态。            | 高动态负载场景（如微服务）。  |
| **分布式限流**      | 通过共享存储（如Redis）协调多节点的全局限流状态。                     | 支持集群统一限流。            | 依赖外部存储，可能有性能瓶颈。        | 分布式系统（如微服务集群）。  |
### 业务选择
- **简单需求**：固定窗口或令牌桶
- **高精度限流**：滑动窗口
- **绝对平滑流量**：漏桶
- **突发流量+资源利用**：令牌桶或自适应
- **分布式系统**：Redis + 令牌桶/滑动窗口

---

## 🚀 快速开始  
```bash
git clone https://github.com/liaotxcn/DataStructures-Algorithms.git  # 克隆仓库
```
```bash
# 进入目录
cd DataStructures-Algorithms/
cd Python/ 
cd Golang/
```
```bash
python First.py  
go run First.go
```

### 持续更新中...
